/*
* This file was autogenerated using the "odrivetool generate-code" feature.
*
* The file matches a specific firmware version. If you add/remove/rename any
* properties exposed by the ODrive, this file needs to be regenerated, otherwise
* the ODrive will ignore all commands.
*/

#ifndef __ODRIVE_ENDPOINTS_HPP
#define __ODRIVE_ENDPOINTS_HPP


namespace odrive {
    
static constexpr const uint16_t json_crc = 0x7411;

static constexpr const uint16_t per_axis_offset = 158;

enum { 
    VBUS_VOLTAGE = 1,
    SERIAL_NUMBER = 2,
    HW_VERSION_MAJOR = 3,
    HW_VERSION_MINOR = 4,
    HW_VERSION_VARIANT = 5,
    FW_VERSION_MAJOR = 6,
    FW_VERSION_MINOR = 7,
    FW_VERSION_REVISION = 8,
    FW_VERSION_UNRELEASED = 9,
    USER_CONFIG_LOADED = 10,
    BRAKE_RESISTOR_ARMED = 11,
    SYSTEM_STATS__UPTIME = 12,
    SYSTEM_STATS__MIN_HEAP_SPACE = 13,
    SYSTEM_STATS__MIN_STACK_SPACE_AXIS0 = 14,
    SYSTEM_STATS__MIN_STACK_SPACE_AXIS1 = 15,
    SYSTEM_STATS__MIN_STACK_SPACE_COMMS = 16,
    SYSTEM_STATS__MIN_STACK_SPACE_USB = 17,
    SYSTEM_STATS__MIN_STACK_SPACE_UART = 18,
    SYSTEM_STATS__MIN_STACK_SPACE_USB_IRQ = 19,
    SYSTEM_STATS__MIN_STACK_SPACE_STARTUP = 20,
    SYSTEM_STATS__USB__RX_CNT = 21,
    SYSTEM_STATS__USB__TX_CNT = 22,
    SYSTEM_STATS__USB__TX_OVERRUN_CNT = 23,
    SYSTEM_STATS__I2C__ADDR = 24,
    SYSTEM_STATS__I2C__ADDR_MATCH_CNT = 25,
    SYSTEM_STATS__I2C__RX_CNT = 26,
    SYSTEM_STATS__I2C__ERROR_CNT = 27,
    CONFIG__BRAKE_RESISTANCE = 28,
    CONFIG__ENABLE_UART = 29,
    CONFIG__ENABLE_I2C_INSTEAD_OF_CAN = 30,
    CONFIG__ENABLE_ASCII_PROTOCOL_ON_USB = 31,
    CONFIG__DC_BUS_UNDERVOLTAGE_TRIP_LEVEL = 32,
    CONFIG__DC_BUS_OVERVOLTAGE_TRIP_LEVEL = 33,
    CONFIG__GPIO1_PWM_MAPPING__MIN = 35,
    CONFIG__GPIO1_PWM_MAPPING__MAX = 36,
    CONFIG__GPIO2_PWM_MAPPING__MIN = 38,
    CONFIG__GPIO2_PWM_MAPPING__MAX = 39,
    CONFIG__GPIO3_PWM_MAPPING__MIN = 41,
    CONFIG__GPIO3_PWM_MAPPING__MAX = 42,
    CONFIG__GPIO4_PWM_MAPPING__MIN = 44,
    CONFIG__GPIO4_PWM_MAPPING__MAX = 45,
    CONFIG__GPIO3_ANALOG_MAPPING__MIN = 47,
    CONFIG__GPIO3_ANALOG_MAPPING__MAX = 48,
    CONFIG__GPIO4_ANALOG_MAPPING__MIN = 50,
    CONFIG__GPIO4_ANALOG_MAPPING__MAX = 51,
    CAN__NODE_ID = 368,
    CAN__TXMAILBOXCOMPLETECALLBACKCNT = 369,
    CAN__TXMAILBOXABORTCALLBACKCNT = 370,
    CAN__RECEIVED_MSG_CNT = 371,
    CAN__RECEIVED_ACK = 372,
    CAN__UNEXPECTED_ERRORS = 373,
    CAN__UNHANDLED_MESSAGES = 374,
    TEST_PROPERTY = 375,
    SAVE_CONFIGURATION = 385,
    ERASE_CONFIGURATION = 386,
    REBOOT = 387,
    ENTER_DFU_MODE = 388,

    // Per-Axis endpoints (to be used with read_axis_property and write_axis_property)
    AXIS__ERROR = 52,
    AXIS__STEP_DIR_ACTIVE = 53,
    AXIS__CURRENT_STATE = 54,
    AXIS__REQUESTED_STATE = 55,
    AXIS__LOOP_COUNTER = 56,
    AXIS__LOCKIN_STATE = 57,
    AXIS__CONFIG__STARTUP_MOTOR_CALIBRATION = 58,
    AXIS__CONFIG__STARTUP_ENCODER_INDEX_SEARCH = 59,
    AXIS__CONFIG__STARTUP_ENCODER_OFFSET_CALIBRATION = 60,
    AXIS__CONFIG__STARTUP_CLOSED_LOOP_CONTROL = 61,
    AXIS__CONFIG__STARTUP_SENSORLESS_CONTROL = 62,
    AXIS__CONFIG__ENABLE_STEP_DIR = 63,
    AXIS__CONFIG__COUNTS_PER_STEP = 64,
    AXIS__CONFIG__WATCHDOG_TIMEOUT = 65,
    AXIS__CONFIG__STEP_GPIO_PIN = 66,
    AXIS__CONFIG__DIR_GPIO_PIN = 67,
    AXIS__CONFIG__CALIBRATION_LOCKIN__CURRENT = 68,
    AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_TIME = 69,
    AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_DISTANCE = 70,
    AXIS__CONFIG__CALIBRATION_LOCKIN__ACCEL = 71,
    AXIS__CONFIG__CALIBRATION_LOCKIN__VEL = 72,
    AXIS__CONFIG__SENSORLESS_RAMP__CURRENT = 73,
    AXIS__CONFIG__SENSORLESS_RAMP__RAMP_TIME = 74,
    AXIS__CONFIG__SENSORLESS_RAMP__RAMP_DISTANCE = 75,
    AXIS__CONFIG__SENSORLESS_RAMP__ACCEL = 76,
    AXIS__CONFIG__SENSORLESS_RAMP__VEL = 77,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_DISTANCE = 78,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_VEL = 79,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_DISTANCE = 80,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_ENC_IDX = 81,
    AXIS__CONFIG__GENERAL_LOCKIN__CURRENT = 82,
    AXIS__CONFIG__GENERAL_LOCKIN__RAMP_TIME = 83,
    AXIS__CONFIG__GENERAL_LOCKIN__RAMP_DISTANCE = 84,
    AXIS__CONFIG__GENERAL_LOCKIN__ACCEL = 85,
    AXIS__CONFIG__GENERAL_LOCKIN__VEL = 86,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_DISTANCE = 87,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_VEL = 88,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_DISTANCE = 89,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_ENC_IDX = 90,
    AXIS__MOTOR__ERROR = 91,
    AXIS__MOTOR__ARMED_STATE = 92,
    AXIS__MOTOR__IS_CALIBRATED = 93,
    AXIS__MOTOR__CURRENT_MEAS_PHB = 94,
    AXIS__MOTOR__CURRENT_MEAS_PHC = 95,
    AXIS__MOTOR__DC_CALIB_PHB = 96,
    AXIS__MOTOR__DC_CALIB_PHC = 97,
    AXIS__MOTOR__PHASE_CURRENT_REV_GAIN = 98,
    AXIS__MOTOR__THERMAL_CURRENT_LIM = 99,
    AXIS__MOTOR__CURRENT_CONTROL__P_GAIN = 102,
    AXIS__MOTOR__CURRENT_CONTROL__I_GAIN = 103,
    AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_D = 104,
    AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_Q = 105,
    AXIS__MOTOR__CURRENT_CONTROL__IBUS = 106,
    AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_ALPHA = 107,
    AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_BETA = 108,
    AXIS__MOTOR__CURRENT_CONTROL__IQ_SETPOINT = 109,
    AXIS__MOTOR__CURRENT_CONTROL__IQ_MEASURED = 110,
    AXIS__MOTOR__CURRENT_CONTROL__ID_MEASURED = 111,
    AXIS__MOTOR__CURRENT_CONTROL__I_MEASURED_REPORT_FILTER_K = 112,
    AXIS__MOTOR__CURRENT_CONTROL__MAX_ALLOWED_CURRENT = 113,
    AXIS__MOTOR__CURRENT_CONTROL__OVERCURRENT_TRIP_LEVEL = 114,
    AXIS__MOTOR__GATE_DRIVER__DRV_FAULT = 115,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_GENERAL = 116,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ADC_CB_I = 117,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ADC_CB_DC = 118,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_MEAS_R = 119,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_MEAS_L = 120,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ENC_CALIB = 121,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_IDX_SEARCH = 122,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_FOC_VOLTAGE = 123,
    AXIS__MOTOR__TIMING_LOG__TIMING_LOG_FOC_CURRENT = 124,
    AXIS__MOTOR__CONFIG__PRE_CALIBRATED = 125,
    AXIS__MOTOR__CONFIG__POLE_PAIRS = 126,
    AXIS__MOTOR__CONFIG__CALIBRATION_CURRENT = 127,
    AXIS__MOTOR__CONFIG__RESISTANCE_CALIB_MAX_VOLTAGE = 128,
    AXIS__MOTOR__CONFIG__PHASE_INDUCTANCE = 129,
    AXIS__MOTOR__CONFIG__PHASE_RESISTANCE = 130,
    AXIS__MOTOR__CONFIG__DIRECTION = 131,
    AXIS__MOTOR__CONFIG__MOTOR_TYPE = 132,
    AXIS__MOTOR__CONFIG__CURRENT_LIM = 133,
    AXIS__MOTOR__CONFIG__CURRENT_LIM_TOLERANCE = 134,
    AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_LOWER = 135,
    AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_UPPER = 136,
    AXIS__MOTOR__CONFIG__REQUESTED_CURRENT_RANGE = 137,
    AXIS__MOTOR__CONFIG__CURRENT_CONTROL_BANDWIDTH = 138,
    AXIS__CONTROLLER__ERROR = 139,
    AXIS__CONTROLLER__POS_SETPOINT = 140,
    AXIS__CONTROLLER__VEL_SETPOINT = 141,
    AXIS__CONTROLLER__VEL_INTEGRATOR_CURRENT = 142,
    AXIS__CONTROLLER__CURRENT_SETPOINT = 143,
    AXIS__CONTROLLER__VEL_RAMP_TARGET = 144,
    AXIS__CONTROLLER__VEL_RAMP_ENABLE = 145,
    AXIS__CONTROLLER__CONFIG__CONTROL_MODE = 146,
    AXIS__CONTROLLER__CONFIG__POS_GAIN = 147,
    AXIS__CONTROLLER__CONFIG__VEL_GAIN = 148,
    AXIS__CONTROLLER__CONFIG__VEL_INTEGRATOR_GAIN = 149,
    AXIS__CONTROLLER__CONFIG__VEL_LIMIT = 150,
    AXIS__CONTROLLER__CONFIG__VEL_LIMIT_TOLERANCE = 151,
    AXIS__CONTROLLER__CONFIG__VEL_RAMP_RATE = 152,
    AXIS__CONTROLLER__CONFIG__SETPOINTS_IN_CPR = 153,
    AXIS__CONTROLLER__START_ANTICOGGING_CALIBRATION = 168,
    AXIS__ENCODER__ERROR = 169,
    AXIS__ENCODER__IS_READY = 170,
    AXIS__ENCODER__INDEX_FOUND = 171,
    AXIS__ENCODER__SHADOW_COUNT = 172,
    AXIS__ENCODER__COUNT_IN_CPR = 173,
    AXIS__ENCODER__INTERPOLATION = 174,
    AXIS__ENCODER__PHASE = 175,
    AXIS__ENCODER__POS_ESTIMATE = 176,
    AXIS__ENCODER__POS_CPR = 177,
    AXIS__ENCODER__HALL_STATE = 178,
    AXIS__ENCODER__VEL_ESTIMATE = 179,
    AXIS__ENCODER__CALIB_SCAN_RESPONSE = 180,
    AXIS__ENCODER__CONFIG__MODE = 181,
    AXIS__ENCODER__CONFIG__USE_INDEX = 182,
    AXIS__ENCODER__CONFIG__FIND_IDX_ON_LOCKIN_ONLY = 183,
    AXIS__ENCODER__CONFIG__PRE_CALIBRATED = 184,
    AXIS__ENCODER__CONFIG__ZERO_COUNT_ON_FIND_IDX = 185,
    AXIS__ENCODER__CONFIG__CPR = 186,
    AXIS__ENCODER__CONFIG__OFFSET = 187,
    AXIS__ENCODER__CONFIG__OFFSET_FLOAT = 188,
    AXIS__ENCODER__CONFIG__ENABLE_PHASE_INTERPOLATION = 189,
    AXIS__ENCODER__CONFIG__BANDWIDTH = 190,
    AXIS__ENCODER__CONFIG__CALIB_RANGE = 191,
    AXIS__ENCODER__CONFIG__CALIB_SCAN_DISTANCE = 192,
    AXIS__ENCODER__CONFIG__CALIB_SCAN_OMEGA = 193,
    AXIS__ENCODER__CONFIG__IDX_SEARCH_UNIDIRECTIONAL = 194,
    AXIS__ENCODER__CONFIG__IGNORE_ILLEGAL_HALL_STATE = 195,
    AXIS__SENSORLESS_ESTIMATOR__ERROR = 198,
    AXIS__SENSORLESS_ESTIMATOR__PHASE = 199,
    AXIS__SENSORLESS_ESTIMATOR__PLL_POS = 200,
    AXIS__SENSORLESS_ESTIMATOR__VEL_ESTIMATE = 201,
    AXIS__SENSORLESS_ESTIMATOR__CONFIG__OBSERVER_GAIN = 202,
    AXIS__SENSORLESS_ESTIMATOR__CONFIG__PLL_BANDWIDTH = 203,
    AXIS__SENSORLESS_ESTIMATOR__CONFIG__PM_FLUX_LINKAGE = 204,
    AXIS__TRAP_TRAJ__CONFIG__VEL_LIMIT = 205,
    AXIS__TRAP_TRAJ__CONFIG__ACCEL_LIMIT = 206,
    AXIS__TRAP_TRAJ__CONFIG__DECEL_LIMIT = 207,
    AXIS__TRAP_TRAJ__CONFIG__A_PER_CSS = 208,
    AXIS__WATCHDOG_FEED = 209,
};

template<int I>
struct endpoint_type;

template<> struct endpoint_type<VBUS_VOLTAGE> { typedef float type; };
template<> struct endpoint_type<SERIAL_NUMBER> { typedef uint64_t type; };
template<> struct endpoint_type<HW_VERSION_MAJOR> { typedef uint8_t type; };
template<> struct endpoint_type<HW_VERSION_MINOR> { typedef uint8_t type; };
template<> struct endpoint_type<HW_VERSION_VARIANT> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_MAJOR> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_MINOR> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_REVISION> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_UNRELEASED> { typedef uint8_t type; };
template<> struct endpoint_type<USER_CONFIG_LOADED> { typedef bool type; };
template<> struct endpoint_type<BRAKE_RESISTOR_ARMED> { typedef bool type; };
template<> struct endpoint_type<SYSTEM_STATS__UPTIME> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_HEAP_SPACE> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_AXIS0> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_AXIS1> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_COMMS> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_USB> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_UART> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_USB_IRQ> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_STARTUP> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__RX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__TX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__TX_OVERRUN_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ADDR> { typedef uint8_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ADDR_MATCH_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__RX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ERROR_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<CONFIG__BRAKE_RESISTANCE> { typedef float type; };
template<> struct endpoint_type<CONFIG__ENABLE_UART> { typedef bool type; };
template<> struct endpoint_type<CONFIG__ENABLE_I2C_INSTEAD_OF_CAN> { typedef bool type; };
template<> struct endpoint_type<CONFIG__ENABLE_ASCII_PROTOCOL_ON_USB> { typedef bool type; };
template<> struct endpoint_type<CONFIG__DC_BUS_UNDERVOLTAGE_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_BUS_OVERVOLTAGE_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO1_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO1_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO2_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO2_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_ANALOG_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_ANALOG_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_ANALOG_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_ANALOG_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CAN__NODE_ID> { typedef uint8_t type; };
template<> struct endpoint_type<CAN__TXMAILBOXCOMPLETECALLBACKCNT> { typedef uint32_t type; };
template<> struct endpoint_type<CAN__TXMAILBOXABORTCALLBACKCNT> { typedef uint32_t type; };
template<> struct endpoint_type<CAN__RECEIVED_MSG_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<CAN__RECEIVED_ACK> { typedef uint32_t type; };
template<> struct endpoint_type<CAN__UNEXPECTED_ERRORS> { typedef uint32_t type; };
template<> struct endpoint_type<CAN__UNHANDLED_MESSAGES> { typedef uint32_t type; };
template<> struct endpoint_type<TEST_PROPERTY> { typedef uint32_t type; };
template<> struct endpoint_type<SAVE_CONFIGURATION> { typedef void type; };
template<> struct endpoint_type<ERASE_CONFIGURATION> { typedef void type; };
template<> struct endpoint_type<REBOOT> { typedef void type; };
template<> struct endpoint_type<ENTER_DFU_MODE> { typedef void type; };


// Per-axis endpoints
template<> struct endpoint_type<AXIS__ERROR> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__STEP_DIR_ACTIVE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CURRENT_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__REQUESTED_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__LOOP_COUNTER> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__LOCKIN_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_MOTOR_CALIBRATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_ENCODER_INDEX_SEARCH> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_ENCODER_OFFSET_CALIBRATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_CLOSED_LOOP_CONTROL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_SENSORLESS_CONTROL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__ENABLE_STEP_DIR> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__COUNTS_PER_STEP> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__WATCHDOG_TIMEOUT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__STEP_GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__CONFIG__DIR_GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__ACCEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__RAMP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__RAMP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__ACCEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_VEL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_DISTANCE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_ENC_IDX> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__RAMP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__RAMP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__ACCEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_VEL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_DISTANCE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_ENC_IDX> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__ERROR> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__ARMED_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__MOTOR__IS_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_MEAS_PHB> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_MEAS_PHC> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__DC_CALIB_PHB> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__DC_CALIB_PHC> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__PHASE_CURRENT_REV_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__THERMAL_CURRENT_LIM> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__P_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__I_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_D> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_Q> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IBUS> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_ALPHA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_BETA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IQ_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IQ_MEASURED> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__ID_MEASURED> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__I_MEASURED_REPORT_FILTER_K> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__MAX_ALLOWED_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__OVERCURRENT_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__GATE_DRIVER__DRV_FAULT> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_GENERAL> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ADC_CB_I> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ADC_CB_DC> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_MEAS_R> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_MEAS_L> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_ENC_CALIB> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_IDX_SEARCH> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_FOC_VOLTAGE> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__TIMING_LOG_FOC_CURRENT> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__POLE_PAIRS> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CALIBRATION_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__RESISTANCE_CALIB_MAX_VOLTAGE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PHASE_INDUCTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PHASE_RESISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__DIRECTION> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__MOTOR_TYPE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_LIM> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_LIM_TOLERANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_LOWER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_UPPER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__REQUESTED_CURRENT_RANGE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_CONTROL_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__ERROR> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__POS_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_INTEGRATOR_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CURRENT_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_RAMP_TARGET> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_RAMP_ENABLE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__CONTROL_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__POS_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_INTEGRATOR_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_LIMIT_TOLERANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_RAMP_RATE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__SETPOINTS_IN_CPR> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__START_ANTICOGGING_CALIBRATION> { typedef void type; };
template<> struct endpoint_type<AXIS__ENCODER__ERROR> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__ENCODER__IS_READY> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__INDEX_FOUND> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__SHADOW_COUNT> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__COUNT_IN_CPR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__INTERPOLATION> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_CPR> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__HALL_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__ENCODER__VEL_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CALIB_SCAN_RESPONSE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__MODE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__USE_INDEX> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__FIND_IDX_ON_LOCKIN_ONLY> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__ZERO_COUNT_ON_FIND_IDX> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CPR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__OFFSET> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__OFFSET_FLOAT> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__ENABLE_PHASE_INTERPOLATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_RANGE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_SCAN_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_SCAN_OMEGA> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__IDX_SEARCH_UNIDIRECTIONAL> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__IGNORE_ILLEGAL_HALL_STATE> { typedef bool type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__ERROR> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PLL_POS> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__VEL_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__CONFIG__OBSERVER_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__CONFIG__PLL_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__CONFIG__PM_FLUX_LINKAGE> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__VEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__ACCEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__DECEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__A_PER_CSS> { typedef float type; };
template<> struct endpoint_type<AXIS__WATCHDOG_FEED> { typedef void type; };


template<int I>
using endpoint_type_t = typename endpoint_type<I>::type;

}

#endif // __ODRIVE_ENDPOINTS_HPP
